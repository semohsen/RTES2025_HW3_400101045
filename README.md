# Linux Signals and IPC (Inter-Process Communication)

---

## ‚ùì What is the difference between `SIGINT` and `SIGKILL`?

- **SIGINT** (Signal `2`):  
  - Meaning: Interrupt signal  
  - Generated by: Typically `Ctrl + C` in terminal  
  - Can be caught or handled: ‚úÖ Yes  
  - Effect: Tells the process to **gracefully stop**, allowing cleanup of resources  

- **SIGKILL** (Signal `9`):  
  - Meaning: Kill process immediately  
  - Generated by: Command `kill -9 <pid>`  
  - Can be caught or handled: ‚ùå No ‚Äî cannot be caught, blocked, or ignored  
  - Effect: **Forcibly stops** the process without cleanup

> üîπ Use `SIGINT` when you want the process to clean up resources before exiting.  
> üîπ Use `SIGKILL` only when the process won‚Äôt terminate normally.

---

## ‚ùì Which signals can be caught or handled by a process?

Most signals **can be caught or handled**, except:

- **SIGKILL (9)**: Cannot be caught, blocked, or ignored  
- **SIGSTOP (19)**: Stops (pauses) a process, also uncatchable

All other signals (like `SIGINT`, `SIGTERM`, `SIGHUP`, `SIGUSR1`, etc.) can be:
- Handled using `signal()` or `sigaction()`
- Often ignored
- Used for custom behavior such as logging or cleanup

---

## ‚ùì How many signals are defined in Linux?

- There are **31 standard signals** defined in `<signal.h>` (numbered 1‚Äì31)
- Additionally, Linux supports **real-time signals**:
  - Range: `SIGRTMIN` to `SIGRTMAX`
  - Typically 32 real-time signals
  - Exact count may vary (use `sysconf(_SC_RTSIG_MAX)`)

üëâ In total, Linux supports approximately **64 signals** (standard + real-time)

---

## ‚úÖ Example Signals

| Signal   | Number | Description                     |
|----------|--------|---------------------------------|
| `SIGINT` | 2      | Interrupt from keyboard         |
| `SIGTERM`| 15     | Termination request             |
| `SIGKILL`| 9      | Kill process immediately        |
| `SIGSEGV`| 11     | Invalid memory access           |
| `SIGUSR1`| 10     | User-defined signal 1           |
| `SIGSTOP`| 19     | Stop the process (pause)        |

---

## ‚ùì What are the key differences between FIFO and Shared Memory for IPC?

### FIFO (Named Pipe)
- Definition: Byte stream communication channel
- Communication: Unidirectional or bidirectional stream
- Speed: Slower due to kernel buffering
- Synchronization: Not inherently needed; blocking I/O helps
- Persistence: Remains until deleted (`mkfifo`, typically `/tmp/pipe`)
- Setup: Simple (`mkfifo`, `open`, `read`, `write`)
- Best use case: Simple command input, logging
- Communication model: Producer-consumer via stream
- Kernel involvement: High ‚Äî every operation goes through the kernel

### Shared Memory
- Definition: Memory region shared between processes
- Communication: Direct memory-based (random access)
- Speed: Much faster ‚Äî no copying required
- Synchronization: Requires explicit mechanisms (semaphores, mutexes)
- Persistence: Exists until unmapped/unlinked by all processes
- Setup: More complex (`shm_open`, `mmap`, sync primitives)
- Best use case: High-speed data exchange, e.g., real-time systems
- Communication model: Shared access to data structures
- Kernel involvement: Low ‚Äî once mapped, it's direct access

> üü¢ Use FIFO for simplicity.  
> üîµ Use Shared Memory for performance.

---
