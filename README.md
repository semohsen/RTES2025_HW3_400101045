‚ùì What is the difference between SIGINT and SIGKILL?
Feature	SIGINT	SIGKILL
Signal #	2	9
Meaning	Interrupt	Kill process immediately
Generated by	Typically Ctrl + C in terminal	Sent via kill -9 <pid>
Can be caught/handled?	‚úÖ Yes	‚ùå No ‚Äî it cannot be caught, blocked, or ignored
Effect	Tells a process to gracefully stop	Immediately stops the process (brutally)
‚û°Ô∏è Use SIGINT if you want the process to clean up resources before exiting.
‚û°Ô∏è Use SIGKILL only when the process won‚Äôt terminate normally.
________________________________________
‚ùì Which signals can be caught or handled by a process?
A process can catch or handle most signals, except these two:
Signal	Description
SIGKILL (9)	Cannot be caught, blocked, or ignored
SIGSTOP (19)	Stops (pauses) a process, also uncatchable
All other signals (like SIGINT, SIGTERM, SIGHUP, SIGUSR1, etc.) can be:
‚Ä¢	Caught using signal() or sigaction()
‚Ä¢	Ignored (in many cases)
‚Ä¢	Used for custom behavior, like logging or cleanup
________________________________________
‚ùì How many signals are defined in Linux?
There are typically 31 standard signals, numbered 1 to 31, defined in <signal.h>.
Additionally, Linux supports real-time signals:
‚Ä¢	Range: SIGRTMIN to SIGRTMAX
‚Ä¢	Typically 32 real-time signals, but the exact number can vary (check via sysconf(_SC_RTSIG_MAX))
üëâ So in total, Linux supports around 64 signals (standard + real-time).
________________________________________
‚úÖ Example Signals
Signal	Number	Description
SIGINT	2	Interrupt from keyboard
SIGTERM	15	Termination request
SIGKILL	9	Kill process immediately
SIGSEGV	11	Invalid memory access
SIGUSR1	10	User-defined signal 1
SIGSTOP	19	Stop the process (pause)


‚ùì What are the key differences between FIFO and shared memory for IPC?

Feature	                FIFO (Named Pipe)                                      	Shared Memory
Definition     	A byte stream communication channel (like a pipe).	             A memory region shared between processes.
Communication   Type	Unidirectional or bidirectional stream                  	   Memory-based (random access)
Speed	Slower    (due to kernel buffering and copying)	                             Much faster (no copying; direct memory access)
Synchronization	 Not needed inherently (acts like a file); blocking I/O helps	   Requires explicit sync (e.g., semaphores, mutexes)
Persistence	FIFO is persistent until deleted (mkfifo, /tmp/pipe)	             Shared memory persists only until all processes unmap/unlink
Setup Complexity	Simple (mkfifo, open/read/write)                             	More complex (requires shm_open, mmap, sync primitives)
Best Use Case	Simple stream communication (e.g., logging, command input)	      High-speed data exchange (e.g., real-time systems, buffers)
Communication Model	Producer-consumer via stream	                              Shared data structure access
Kernel Involvement	More (each read/write goes through kernel)	                 Less (once mapped, direct memory access)
Example Scenario 	Shell piping, command queues	                                Shared buffers, sensor data exchange, real-time schedulers



